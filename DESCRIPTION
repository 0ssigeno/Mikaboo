Il nostro progetto è composto da 6 file principali, più ovviamente i file di test che dovranno essere svolti.
Ogni file C ha il corrispondente header dove sono descritte le funzioni.
Il file const.h contiene tutte le variabili globali che verranno utilizzate nel programma e tutti i #define utili alla comprensione del codice.


Una breve panoramica dei file: boot.c si occupa della inizializzazione delle strutture basi(create in phase1 nel file mikabooq.c), delle aree di memoria dedicate, del SSI e del programma test. 
Successivamente è il momento dello scheduler.c che si occupa di settare a current_thread un thread della ready queue o, se possibile, dare precedenza all SSI. Si occupa inoltre di controllare i casi di terminazione, e di settare e controllare i time slice e la pseudo_clock queue.
SSI.c contiene tutte le funzioni necessarie a gestire i servizi. 
Funzioni che non si occupano di rispondere direttamente al servizio richiesto, sono la check_death che controlla e sveglia se,una volta ucciso un thread, ci sono altri thread in attesa di un messaggio da quello ucciso. La exterminate thread e process si occupano di terminare rispettivamente un thread e/o un processo, con delle particolari scelte di progettazione che descriveremo precisamente dopo.
Non sempre è l'ssi a dover rispondere al thread che ha invocato il servizio, può succedere che sia un handler a dovere mandare il messaggio di risposta o un terminale che mandi l'acknowledge.
In exception.c vi è la gestione degli handler: system, program e tlb. Si trovano al suo interno le funzioni per inviare e ricevere messaggi, per mettere un processo nella ready queue(svegliarlo) o per metterlo nella wait queue(addormentarlo).
Interrupt.c invece gestisce gli interrupt attraverso inthandler; al suo interno vi è una struttura usata per gestire le code dei device, dei terminali. Vi è anche il controllo sui time slice e la funzione ack gestisce le risposte dei device.

Piccolo inciso che riguarda modifiche effettuate a phase1(mikabooq.c)per poter implementare tutti i servizi richiesti: i processi ora contengono 3 puntatori ai propri manager: system, tlb e prg. Anche i thread possiedono 3 nuovi campi, un error number e due che riguardano i tempi:cpu time gestisce CHECK mentre elapsed time gestisce CHECK .

Ora è il momento di guardare in maniera dettagliata i singoli file di questa phase e ancora più precisamente, le singole funzioni.


Partiamo nuovamente da boot.c

Il main verrà eseguito una sola volta, il controllo non tornerà mai al boot ma rimbalzerà tra gli altri file.
Vengono inizializzate i device, le strutture create da mikabooq e successivamente le 4 aree di memoria con i relativi handler.
Vengono creati i processi SSI e test e il relativo thread e infine, prima di eseguire lo scheduler per la prima volta, vengono posti nella ready queue.Non vi sono scelte progettuali in questa sezione, escludendo la funzione init_dev_ctrl che crea le code per i device.

Seguendo l'ordine, il prossimo file è lo scheduler.c

La funzione principale si chiama scheduler() e ha due compiti principali: gestire i casi di deadlock/wait/halt della macchina, e caricare il processo corrente. Abbiamo preso la decisione che il processo corrente è sempre, se possibile, l SSI in modo da velocizzare l'esecuzione.
Ad ogni chiamata dello scheduler viene settato il prossimo timer, e di questa funzione è necessario parlare nei dettagli: CHECK.
PARLARE DI SET_PSEUDO_CLOCK.
La funzione is_time_slice invece è solo di supporto(al timer handler)e controlla se è finito o meno il timeslice del thread.

SSI.c si occupa di gestire tutti i servizi che li richiedono e la sua funzione principale è SSI_main_task: controlla se è una richiesta accettabile e in caso affermativo, chiama la funzione corrispondente e inserisce in reply la risposta. Non sempre deve rispondere al messaggio del richiedente del servizio(possono essere pure gli handler o i messaggi di acknowledge), e a seconda del valore restituto a ssi_entry viene fatta la send o meno.
I servizi sono abbastanza lineari e non presentano segni degni di nota, apparte il fatto che spesso restituiscono campi creati appositamente e che vengono gestiti opportunatamente il numero di thread totali e di quelli softblockati(rispettivamente nella create e nella exterminate). Una piccola scelta di progettazione è stata l'uccisione dei thread e successivamente dei processi.Quando un thread viene terminato ed è l'unico thread del procsso, allora anche il processo viene terminato. Se un processo viene terminato, allora anche tutti i suoi thread vengono uccisi. Se un processo è ucciso allora tutti i suoi processi figli vengono uccisi(questo perchè per specifiche di phase 1 non possono esistere processi con padre==NULL escluso il processo root).
Nelle funzioni che eliminano processi/thread, vi è pure la chiamata ad una funzione che gestisce casi di errori:la check_death.
Essa si occupa di controllare se, una volta ucciso un thread, ci sono altri thread in attesa di una risposta da questo. Se la risposta è affermativa, setta il loro err_numb e li sveglia con un messaggio inviato dall'SSI.
Una funzione forse non propriamente lienare è la SSI_do_io: CHECK.

In exception.c ci sono varie funzioni "di supporto":put_thred_sleep and wake_me_up sono una l'opposto dell'altra: mentre la prima posiziona un thread nella wait_queue e aumenta il numero di softblock la seconda sposta nella ready_queue e diminuisci il numero di processi softblockati.
Un'altra con un compito nato da una esigenza particolare è check_thread_alive. Mentre la check_death si occupa di svegliare thread che erano in attesa di un thread ucciso, la check_thread_alive controlla che non si voglia inviare ad un thread che non fa parte di quelli vivi: se non esiste, allora il messaggio non viene spedito e nel campo apposito err_numb viene settato l'errore.
Sys_send_msg si occupa di inviare un messaggio da un thread ad un altro, ma ha una particolarità in più:se il ricevente aspetta già un messaggio dal mittente, non viene incodato in messaggio ma viene direttamente svegliato il thread in attesa.
Ora è il momento di controllare i tre handler: tlb e pgm controllano che il rispettivo thread sia abilitato e in caso affermativo, mettono nella wait queue il thread corrente e svegliano il manager.
La sys_bp_handler è la funzione cuore del file:essa viene invocata quando un thread richiede un servizio o una system call(send recv).
E' necessario quindi controllare i permessi del thread: se è in user mode e richiede una system call, deve essere invocato il suo program manager, se è richiesto un servizio, il system manager; se è in kernel mode invece, può mandare direttamente send e recv.
La send prima di tutto controlla che non si stia inviando ad un morto, successivamente CHECK IF e altrimenti si manda la send con la funzione apposita e si avanza di una word size per evitare di rientrare nel codice della syscall.
Anche la recv controlla che si stia ricevendo da un processo esistente e dopo aver fatto la msgq_get controlla se ha ricevuto o meno il messaggio. Se non lo ha ricevuto va messo nella wait queue, settati i campi e non va avanzato di una wordsize in modo che poi ritorni nel codice della syscall; se invece la msgq_get va a buon fine invece, carico i vari campi in maniera adeguata e faccio il load del processo.
Tutti i casi di errore di questa sezione vengono risolti con l'uccisione del processo.

L'ultimo file che è rimasto da descrivere è interrupts.c e come enuncia il nome, si occupa di gestire tutti gli interrupt che arrivano da parte di uArm. La funzione principale è int_handler la quale controlla la causa dell'interrupt e a seconda del tipo di interrupt ricevuto chiama la funzione adeguata per poi richiamare lo scheduler e far continuare l'esecuzione del programma.
Tutti gl interrupt vengono esclusi dal device_handler, escludendo la causa TIMER che viene gestita dal timer_handler e controlla se è finito o meno il time_slice, e la causa TERMINAL che ha il controllo se è stata effettuata una scrittura o una lettura.
CHECK SE SCENDERE NEI DETTAGLI DEI CONTI
Sia la device_handler che la terminal_handler utilizzano la funzione ack() che ha lo scopo oltre a rispondere ai thread in attesa(non sempre è l'ssi a rispondere come è già stato accennato sopra)ma anche di incodare il thread nella giusta lista.

Il file è stato adeguatamente commentato, abbiamo deciso di non andare troppo nei dettagli nella presentazione per il semplice motivo che la comprensione del codice è relativamente facile e dove non lo è riteniamo che sia commentato a sufficienza, secondo noi infatti è più importante spiegare il funzionamento generale del programma in una relazione.

Inoltre abbiamo portato un ulteriore test, è esattamente uguale al p2test.c solamente che ogni processo lavora in maniera parallela e su un terminale diverso.





