Il nostro progetto è composto da 6 file principali, più ovviamente i file di test che dovranno essere svolti.
Ogni file C ha il corrispondente header dove sono descritte le funzioni.
Il file const.h contiene tutte le variabili globali che verranno utilizzate nel programma e tutti i #define utili alla comprensione del codice.


Una breve panoramica dei file: boot.c si occupa della inizializzazione delle strutture basi(create in phase1 nel file mikabooq.c), delle aree di memoria dedicate, del SSI e del programma test. 
Successivamente è il momento dello scheduler.c che si occupa di settare a current_thread un thread della ready queue o, se possibile, dare precedenza all SSI. Si occupa inoltre di controllare i casi di terminazione, e di settare e controllare i time slice e la pseudo_clock queue.
SSI.c contiene tutte le funzioni necessarie a gestire i servizi. 
Funzioni che non si occupano di rispondere direttamente al servizio richiesto, sono la check_death che controlla e sveglia se,una volta ucciso un thread, ci sono altri thread in attesa di un messaggio da quello ucciso. La exterminate thread e process si occupano di terminare rispettivamente un thread e/o un processo, con delle particolari scelte di progettazione che descriveremo precisamente dopo.
Non sempre è l'ssi a dover rispondere al thread che ha invocato il servizio, può succedere che sia un handler a dovere mandare il messaggio di risposta o un terminale che mandi l'acknowledge.
In exception.c vi è la gestione degli handler: system, program e tlb. Si trovano al suo interno le funzioni per inviare e ricevere messaggi, per mettere un processo nella ready queue(svegliarlo) o per metterlo nella wait queue(addormentarlo).
Interrupt.c invece gestisce gli interrupt attraverso inthandler; al suo interno vi è una struttura usata per gestire le code dei device, dei terminali. Vi è anche il controllo sui time slice e la funzione ack gestisce le risposte dei device.

Piccolo inciso che riguarda modifiche effettuate a phase1(mikabooq.c)per poter implementare tutti i servizi richiesti: i processi ora contengono 3 puntatori ai propri manager: system, tlb e prg. Anche i thread possiedono 3 nuovi campi, un error number e due che riguardano i tempi:cpu time gestisce CHECK mentre elapsed time gestisce CHECK .

Ora è il momento di guardare in maniera dettagliata i singoli file di questa phase e ancora più precisamente, le singole funzioni.


Partiamo nuovamente da boot.c

Il main verrà eseguito una sola volta, il controllo non tornerà mai al boot ma rimbalzerà tra gli altri file.
Vengono inizializzate i device, le strutture create da mikabooq e successivamente le 4 aree di memoria con i relativi handler.
Vengono creati i processi SSI e test e il relativo thread e infine, prima di eseguire lo scheduler per la prima volta, vengono posti nella ready queue.Non vi sono scelte progettuali in questa sezione, escludendo la funzione init_dev_ctrl che crea le code per i device.

Seguendo l'ordine, il prossimo file è lo scheduler.c

La funzione principale si chiama scheduler() e ha due compiti principali: gestire i casi di deadlock/wait/halt della macchina, e caricare il processo corrente. Abbiamo preso la decisione che il processo corrente è sempre, se possibile, l SSI in modo da velocizzare l'esecuzione.
Ad ogni chiamata dello scheduler viene settato il prossimo timer, e di questa funzione è necessario parlare nei dettagli: CHECK.
PARLARE DI SET_PSEUDO_CLOCK.
La funzione is_time_slice invece è solo di supporto(al timer handler)e controlla se è finito o meno il timeslice del thread.

SSI.c si occupa di gestire tutti i servizi che li richiedono e la sua funzione principale è SSI_main_task: controlla se è una richiesta accettabile e in caso affermativo, chiama la funzione corrispondente e inserisce in reply la risposta. Non sempre deve rispondere al messaggio del richiedente del servizio(possono essere pure gli handler o i messaggi di acknowledge), e a seconda del valore restituto a ssi_entry viene fatta la send o meno.
I servizi sono abbastanza lineari e non presentano segni degni di nota, apparte il fatto che spesso restituiscono campi creati appositamente e che vengono gestiti opportunatamente il numero di thread totali e di quelli softblockati(rispettivamente nella create e nella exterminate). Una piccola scelta di progettazione è stata l'uccisione dei thread e successivamente dei processi.Quando un thread viene terminato ed è l'unico thread del procsso, allora anche il processo viene terminato. Se un processo viene terminato, allora anche tutti i suoi thread vengono uccisi. Se un processo è ucciso allora tutti i suoi processi figli vengono uccisi(questo perchè per specifiche di phase 1 non possono esistere processi con padre==NULL escluso il processo root).
Nelle funzioni che eliminano processi/thread, vi è pure la chiamata ad una funzione che gestisce casi di errori:la check_death.
Essa si occupa di controllare se, una volta ucciso un thread, ci sono altri thread in attesa di una risposta da questo. Se la risposta è affermativa, setta il loro err_numb e li sveglia con un messaggio inviato dall'SSI.
Una funzione forse non propriamente lienare è la SSI_do_io: CHECK.

In exception.c ci sono varie funzioni "di supporto":put_thred_sleep and wake_me_up sono una l'opposto dell'altra: mentre la prima posiziona un thread nella wait_queue e aumenta il numero di softblock la seconda sposta nella ready_queue e diminuisci il numero di processi softblockati.






