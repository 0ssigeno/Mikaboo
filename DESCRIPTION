Il nostro progetto è composto da 6 file principali, più ovviamente i file di test che dovranno essere svolti.
Ogni file C ha il corrispondente header dove sono descritte le funzioni.
Il file const.h contiene tutte le variabili globali che verranno utilizzate nel programma e tutti i #define utili alla comprensione del codice.


Una breve panoramica dei file: boot.c si occupa della inizializzazione delle strutture basi(create in phase1 nel file mikabooq.c), delle aree di memoria dedicate, del SSI e del programma test. 
Successivamente è il momento dello scheduler.c che si occupa di settare a current_thread un thread della ready queue o, se possibile, dare precedenza all SSI. Si occupa inoltre di controllare i casi di terminazione, e di settare e controllare i time slice e la pseudo_clock queue.
SSI.c contiene tutte le funzioni necessarie a gestire i servizi. 
Funzioni che non si occupano di rispondere direttamente al servizio richiesto, sono la check_death che controlla e sveglia se,una volta ucciso un thread, ci sono altri thread in attesa di un messaggio da quello ucciso. La exterminate thread e process si occupano di terminare rispettivamente un thread e/o un processo, con delle particolari scelte di progettazione che descriveremo precisamente dopo.
Non sempre è l'ssi a dover rispondere al thread che ha invocato il servizio, può succedere che sia un handler a dovere mandare il messaggio di risposta o un terminale che mandi l'acknowledge.
In exception.c vi è la gestione degli handler: system, program e tlb. Si trovano al suo interno le funzioni per inviare e ricevere messaggi, per mettere un processo nella ready queue(svegliarlo) o per metterlo nella wait queue(addormentarlo).
Interrupt.c invece gestisce gli interrupt attraverso inthandler; al suo interno vi è una struttura usata per gestire le code dei device, dei terminali. Vi è anche il controllo sui time slice e la funzione ack gestisce le risposte dei device.

Piccolo inciso che riguarda modifiche effettuate a phase1(mikabooq.c)per poter implementare tutti i servizi richiesti: i processi ora contengono 3 puntatori ai propri manager: system, tlb e prg. Anche i thread possiedono 3 nuovi campi, un error number e due che riguardano i tempi:cpu time esprime il tempo per il quale il thread ha occupato la CPU, mentre elapsed time esprime il tempo di attesa da quando c'è stata una chiamata alla wait for clock.
Inoltre abbiamo creato la reset state che setta tutti i campi di uno state a 0, la thread_in_queue che controlla se un thread è presente in una determinata coda oppure no.

Ora è il momento di guardare in maniera dettagliata i singoli file di questa phase e ancora più precisamente, le singole funzioni.


Partiamo nuovamente da boot.c

Il main verrà eseguito una sola volta, il controllo non tornerà mai al boot ma rimbalzerà tra gli altri file.
Vengono inizializzate i device, le strutture create da mikabooq e successivamente le 4 aree di memoria con i relativi handler.
Vengono creati i processi SSI e test e i relativi thread: in particolare gli interrupt sono abilitati e hanno lo status di kernel mode.
Successivamente, prima di eseguire lo scheduler per la prima volta, vengono posti nella ready queue.
Non vi sono scelte progettuali in questa sezione, escludendo la funzione init_dev_ctrl che crea le code per i device.

Seguendo l'ordine, il prossimo file è lo scheduler.c

La funzione principale si chiama scheduler() e ha due compiti principali: gestire i casi di deadlock/wait/halt della macchina, e caricare il processo corrente. Abbiamo preso la decisione che il processo corrente è sempre, se possibile, l SSI in modo da velocizzare l'esecuzione attraverso la funzione ssi_priority.
Questa funzione estrae dalla ready queue l ssi se presente altrimenti il primo processo in coda.
Ad ogni chiamata dello scheduler viene settato il prossimo timer e la funzione che si occupa di ciò è set_next timer: ci sono tre casi possibili che vengono gestiti da questa funzione insieme al supporto della set_pseudo_clock.
Caso uno) è finito il time slice e setto il time successivo; caso due) il primo processo della pseudo clock queue deve attendere un tempo minore di un time slice: setto il timer a il tempo rimasto dello pseudo clock; caso tre) il primo processo della pseudo clock queue deve attendere un tempo maggiore di un time slice: setto il primo timer al time slice.
Questo avviene perchè essendo una coda fifo che tiene conto dei tempi dei thread necessarriamente, scorrendola i temppi (elapsed time) aumentino; quindi se il primo è maggiore del time slice di conseguenza anche tutti gli altri lo saranno.
La funzione is_time_slice invece è solo di supporto(al timer handler)e controlla se è finito o meno il timeslice del thread ed è stata inserita in questo file poichè usa delle variabili strettamente locali.

SSI.c si occupa di gestire tutti i servizi che li richiedono e la sua funzione principale è SSI_main_task: controlla se è una richiesta accettabile e in caso affermativo, chiama la funzione corrispondente e inserisce in reply la risposta. Non sempre deve rispondere al messaggio del richiedente del servizio(possono essere pure gli handler o i messaggi di acknowledge a rispondere), e a seconda del valore restituto a ssi_entry viene fatta la send o meno al thread che ha richiesto il servizio.
I servizi sono abbastanza lineari e non presentano segni degni di nota, vengono gestiti opportunamente il numero di thread totali e di quelli softblockati(rispettivamente nella create e nella exterminate). Una piccola scelta di progettazione è stata come avviene  l'uccisione dei thread e dei processi.Quando un thread viene terminato ed è l'unico thread del processo, allora anche il processo viene terminato. Se un processo viene terminato, allora anche tutti i suoi thread vengono uccisi. Se un processo è ucciso allora tutti i suoi processi figli vengono uccisi(questo perchè per specifiche di phase 1 non possono esistere processi con padre==NULL escluso il processo root).
Nelle funzioni che eliminano processi/thread, vi è pure la chiamata ad una funzione che gestisce casi di errori:la check_death.
Essa si occupa di controllare se, una volta ucciso un thread, ci sono altri thread in attesa di una risposta da questo. Se la risposta è affermativa, setta il loro err_numb e li sveglia con un messaggio inviato dall'SSI.
Una funzione forse non propriamente lienare è la SSI_do_io: CHECK.

In exception.c ci sono varie funzioni "di supporto":put_thred_sleep and wake_me_up sono una l'opposto dell'altra: mentre la prima posiziona un thread nella wait_queue e aumenta il numero di softblock la seconda sposta nella ready_queue e diminuisci il numero di processi softblockati.
Un'altra con un compito nato da una esigenza particolare è check_thread_alive. Mentre la check_death si occupa di svegliare thread che erano in attesa di un thread ucciso, la check_thread_alive controlla che non si voglia inviare ad un thread che non fa parte di quelli vivi: se non esiste, allora il messaggio non viene spedito e nel campo apposito err_numb viene settato l'errore.
Sys_send_msg si occupa di inviare un messaggio da un thread ad un altro, ma ha una particolarità in più:se il ricevente aspetta già un messaggio dal mittente, non viene incodato in messaggio ma viene direttamente svegliato il thread in attesa.
Ora è il momento di controllare i tre handler: tlb e pgm controllano che il rispettivo thread sia abilitato e in caso affermativo, mettono nella wait queue il thread corrente e svegliano il manager.
La sys_bp_handler è la funzione cuore del file:essa viene invocata quando un thread richiede un servizio o una system call(send recv).
E' necessario quindi controllare i permessi del thread: se è in user mode e richiede una system call, deve essere invocato il suo program manager, se è richiesto un servizio, il system manager; se è in kernel mode invece, può mandare direttamente send e recv.
La send prima di tutto controlla che non si stia inviando ad un morto, successivamente CHECK IF e altrimenti si manda la send con la funzione apposita e si avanza di una word size per evitare di rientrare nel codice della syscall.
Anche la recv controlla che si stia ricevendo da un processo esistente e dopo aver fatto la msgq_get controlla se ha ricevuto o meno il messaggio. Se non lo ha ricevuto va messo nella wait queue, settati i campi e non va avanzato di una wordsize in modo che poi ritorni nel codice della syscall; se invece la msgq_get va a buon fine invece, carico i vari campi in maniera adeguata e faccio il load del processo.
Tutti i casi di errore di questa sezione vengono risolti con l'uccisione del processo.

L'ultimo file che è rimasto da descrivere è interrupts.c e come enuncia il nome, si occupa di gestire tutti gli interrupt che arrivano da parte di uArm. La funzione principale è int_handler la quale controlla la causa dell'interrupt e a seconda del tipo di interrupt ricevuto chiama la funzione adeguata per poi richiamare lo scheduler e far continuare l'esecuzione del programma.
Tutti gl interrupt vengono esclusi dal device_handler, escludendo la causa TIMER che viene gestita dal timer_handler e controlla se è finito o meno il time_slice, e la causa TERMINAL che ha il controllo se è stata effettuata una scrittura o una lettura.
CHECK SE SCENDERE NEI DETTAGLI DEI CONTI
Sia la device_handler che la terminal_handler utilizzano la funzione ack() che ha lo scopo oltre a rispondere ai thread in attesa(non sempre è l'ssi a rispondere come è già stato accennato sopra)ma anche di incodare il thread nella giusta lista.

Il file è stato adeguatamente commentato, abbiamo deciso di non andare troppo nei dettagli nella presentazione per il semplice motivo che la comprensione del codice è relativamente facile e dove non lo è riteniamo che sia commentato a sufficienza, secondo noi infatti è più importante spiegare il funzionamento generale del programma in una relazione.

Inoltre abbiamo portato un ulteriore test, è esattamente uguale al p2test.c solamente che ogni processo lavora in maniera parallela e su un terminale diverso.





